{"ast":null,"code":"import { createElementVNode as _createElementVNode, vModelText as _vModelText, withDirectives as _withDirectives, createCommentVNode as _createCommentVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\nconst _hoisted_1 = /*#__PURE__*/_createElementVNode(\"h2\", null, \"Cryptocurrency Price Chart\", -1 /* HOISTED */);\nconst _hoisted_2 = {\n  class: \"date-filter\"\n};\nconst _hoisted_3 = /*#__PURE__*/_createElementVNode(\"div\", {\n  id: \"price-chart\"\n}, null, -1 /* HOISTED */);\n\nexport function render(_ctx, _cache) {\n  return _openBlock(), _createElementBlock(\"div\", null, [_hoisted_1, _createElementVNode(\"div\", _hoisted_2, [_withDirectives(_createElementVNode(\"input\", {\n    type: \"date\",\n    \"onUpdate:modelValue\": _cache[0] || (_cache[0] = $event => _ctx.startDate = $event),\n    onChange: _cache[1] || (_cache[1] = (...args) => _ctx.fetchAllCoinData && _ctx.fetchAllCoinData(...args))\n  }, null, 544 /* HYDRATE_EVENTS, NEED_PATCH */), [[_vModelText, _ctx.startDate]]), _withDirectives(_createElementVNode(\"input\", {\n    type: \"date\",\n    \"onUpdate:modelValue\": _cache[2] || (_cache[2] = $event => _ctx.endDate = $event),\n    onChange: _cache[3] || (_cache[3] = (...args) => _ctx.fetchAllCoinData && _ctx.fetchAllCoinData(...args))\n  }, null, 544 /* HYDRATE_EVENTS, NEED_PATCH */), [[_vModelText, _ctx.endDate]])]), _hoisted_3, _createCommentVNode(\" Container for the D3.js chart \")]);\n}","map":{"version":3,"names":["_createElementVNode","class","id","_createElementBlock","_hoisted_1","_hoisted_2","type","_ctx","startDate","$event","onChange","_cache","args","fetchAllCoinData","endDate","_hoisted_3","_createCommentVNode"],"sources":["/Users/stefanstapelberg/Desktop/FSD_PROJECT/CryptoCanvas/crypto-canvas/src/components/PriceOverTime.vue"],"sourcesContent":["<template>\n    <div>\n        <h2>Cryptocurrency Price Chart</h2>\n        <div class=\"date-filter\">\n            <input type=\"date\" v-model=\"startDate\" @change=\"fetchAllCoinData\">\n            <input type=\"date\" v-model=\"endDate\" @change=\"fetchAllCoinData\">\n        </div>\n        <div id=\"price-chart\"></div> <!-- Container for the D3.js chart -->\n    </div>\n</template>\n\n\n<script>\nimport * as d3 from 'd3';\nimport axios from 'axios';\nimport config from './config';\n\nexport default {\n  name: 'PriceChart',\n  data() {\n    return {\n      pricesData: {}\n      startDate: '2016-01-01',\n      endDate: '2021-01-04',\n    };\n  },\n  mounted() {\n    this.fetchAllCoinData();\n  },\n  methods: {\n    async fetchAllCoinData() {\n      try {\n        const response = await axios.get(`${config.backendApiUrl}/getAllCoinData`);\n            params: {\n                startDate: this.startDate,\n                endDate: this.endDate,\n            }\n        this.pricesData = this.processData(response.data.data);\n        this.drawPriceChart();\n      } catch (error) {\n        console.error('Error fetching all coin data:', error);\n      }\n    },\n    processData(data) {\n      const processedData = {};\n      data.forEach(d => {\n        const coin = d.Coin;\n        const date = new Date(d.Date);\n        const price = +d.Close;\n        \n        if (!processedData[coin]) {\n          processedData[coin] = [];\n        }\n        processedData[coin].push({ date, price });\n      });\n      return processedData;\n    },\n    drawPriceChart() {\n      const margin = { top: 5, right: 30, bottom: 30, left: 60 };\n      const width = 460 - margin.left - margin.right;\n      const height = 400 - margin.top - margin.bottom;\n      d3.select('#price-chart').select('svg').remove();\n\n      const svg = d3.select('#price-chart')\n        .append('svg')\n        .attr('width', width + margin.left + margin.right)\n        .attr('height', height + margin.top + margin.bottom)\n        .append('g')\n        .attr('transform', `translate(${margin.left},${margin.top})`);\n\n      const x = d3.scaleTime()\n        .domain(d3.extent(Object.values(this.pricesData).flat(), d => d.date))\n        .range([0, width]);\n      svg.append('g')\n        .attr('transform', `translate(0,${height})`)\n        .call(d3.axisBottom(x));\n\n      const y = d3.scaleLinear()\n        .domain([0, d3.max(Object.values(this.pricesData).flat(), d => d.price)])\n        .range([height, 0]);\n      svg.append('g')\n        .call(d3.axisLeft(y));\n\n      const color = d3.scaleOrdinal()\n        .domain(Object.keys(this.pricesData))\n        .range(d3.schemeSet2);\n\n      Object.keys(this.pricesData).forEach(coin => {\n        svg.append('path')\n          .datum(this.pricesData[coin])\n          .attr('fill', 'none')\n          .attr('stroke', color(coin))\n          .attr('stroke-width', 1.5)\n          .attr('d', d3.line()\n            .x(d => x(d.date))\n            .y(d => y(d.price))\n            \n          );\n      });\n      const legendYPosition = height + margin.bottom + margin.top -10;\n\n\n      const legendSpace = width / Object.keys(this.pricesData).length; // Spacing for legend items\n      Object.keys(this.pricesData).forEach((coin, index) => {\n        svg.append(\"text\")\n            .attr(\"x\", (legendSpace / 2) + index * legendSpace) // Spacing of legend items\n            .attr(\"y\", legendYPosition + 5)\n            .attr(\"class\", \"legend\")    // Style the legend\n            .style(\"fill\", color(coin)) // Add the color\n            .text(coin);\n\n        // Optional: Add colored rectangles next to text if needed\n        svg.append(\"rect\")\n            .attr(\"x\", (legendSpace / 2) - 10 + index * legendSpace)\n            .attr(\"y\", legendYPosition - 5)\n            .attr(\"width\", 10)\n            .attr(\"height\", 10)\n            .style(\"fill\", color(coin));\n        });\n          \n        // Tooltip for line hover\n        const tooltip = d3.select('#price-chart').append('div')\n        .attr('class', 'tooltip')\n        .style('opacity', 0);\n\n        Object.keys(this.pricesData).forEach(coin => {\n            const line = svg.append('path')\n            .datum(this.pricesData[coin])\n            .attr('fill', 'none')\n            .attr('stroke', color(coin))\n            .attr('stroke-width', 1.5)\n            .attr('d', d3.line()\n            .x(d => x(d.date))\n            .y(d => y(d.price))\n            );\n\n     // Event listeners for tooltip\n            line.on('mouseover', () => tooltip.style('opacity', 1))\n            .on('mousemove', function(event, d) {\n            const [xPosition, yPosition] = d3.pointer(event, this);\n            tooltip.html(`Price: ${y.invert(yPosition).toFixed(2)}`)\n            .style('left', (xPosition + 190) + 'px')\n            .style('top', (yPosition + 50) + 'px');\n            })\n            .on('mouseleave', () => tooltip.style('opacity', 0));\n        });\n\n    }\n  }\n}\n</script>\n\n<style>\nh2 {\n  text-align: left;\n  margin-bottom: 10px; /* Reduced bottom margin */\n  margin-top: 20px; /* Add top margin if needed */\n  margin-left: 60px;\n}\n\n#price-chart {\n  padding-top: 20px; /* Add padding to the top of the chart container */\n}\n\n.tooltip {\n  position: absolute;\n  text-align: center;\n  transition: opacity 0.3s;\n}\n\n.legend {\n  font-size: 12px;\n}\n</style>\n\n"],"mappings":";gCAEQA,mBAAA,CAAmC,YAA/B,4BAA0B;;EACzBC,KAAK,EAAC;AAAa;gCAIxBD,mBAAA,CAA4B;EAAvBE,EAAE,EAAC;AAAa;;;uBANzBC,mBAAA,CAOM,cANFC,UAAmC,EACnCJ,mBAAA,CAGM,OAHNK,UAGM,G,gBAFFL,mBAAA,CAAkE;IAA3DM,IAAI,EAAC,MAAM;+DAAUC,IAAA,CAAAC,SAAS,GAAAC,MAAA;IAAGC,QAAM,EAAAC,MAAA,QAAAA,MAAA,UAAAC,IAAA,KAAEL,IAAA,CAAAM,gBAAA,IAAAN,IAAA,CAAAM,gBAAA,IAAAD,IAAA,CAAgB;iEAApCL,IAAA,CAAAC,SAAS,E,mBACrCR,mBAAA,CAAgE;IAAzDM,IAAI,EAAC,MAAM;+DAAUC,IAAA,CAAAO,OAAO,GAAAL,MAAA;IAAGC,QAAM,EAAAC,MAAA,QAAAA,MAAA,UAAAC,IAAA,KAAEL,IAAA,CAAAM,gBAAA,IAAAN,IAAA,CAAAM,gBAAA,IAAAD,IAAA,CAAgB;iEAAlCL,IAAA,CAAAO,OAAO,E,KAEvCC,UAA4B,EAACC,mBAAA,mCAAsC,C"},"metadata":{},"sourceType":"module","externalDependencies":[]}