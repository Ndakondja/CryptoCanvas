{"ast":null,"code":"import { createElementVNode as _createElementVNode, createCommentVNode as _createCommentVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\nconst _hoisted_1 = /*#__PURE__*/_createElementVNode(\"h2\", null, \"Bitcoin Correlation Heatmap\", -1 /* HOISTED */);\nconst _hoisted_2 = /*#__PURE__*/_createElementVNode(\"div\", {\n  id: \"heatmap\"\n}, null, -1 /* HOISTED */);\n\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", null, [_hoisted_1, _hoisted_2, _createCommentVNode(\" Container for the D3.js treemap \")]);\n}","map":{"version":3,"names":["_createElementVNode","id","_createElementBlock","_hoisted_1","_hoisted_2","_createCommentVNode"],"sources":["C:\\Projects\\CryptoCanvas\\crypto-canvas\\src\\components\\CorrelationMatrix.vue"],"sourcesContent":["<!-- eslint-disable no-multiple-empty-lines -->\r\n<template>\r\n  <div>\r\n      <h2>Bitcoin Correlation Heatmap</h2>\r\n      <div id=\"heatmap\"></div> <!-- Container for the D3.js treemap -->\r\n    </div>\r\n</template>\r\n\r\n<script>\r\nimport * as d3 from 'd3'\r\nimport axios from 'axios'\r\nimport config from './config'\r\n\r\nexport default {\r\n  // eslint-disable-next-line vue/multi-word-component-names\r\n  name: 'Heatmap',\r\n  props: {\r\n    selectedTimeRange: {\r\n      type: String,\r\n      default: ''\r\n    },\r\n    selectedCoins: {\r\n      type: Array,\r\n      default: () => []\r\n    }\r\n  },\r\n  mounted () {\r\n    this.fetchCorrelationMatrix()\r\n  },\r\n  // CorrelationMatrix.vue\r\n  watch: {\r\n    selectedTimeRange () {\r\n      this.fetchCorrelationMatrix()\r\n    },\r\n    selectedCoins () {\r\n      this.fetchCorrelationMatrix()\r\n    }\r\n  },\r\n  methods: {\r\n    async fetchCorrelationMatrix () {\r\n      try {\r\n        const coinQueryParam = this.selectedCoins.join(',')\r\n        const response = await axios.get(`${config.backendApiUrl}/getCorrelationMatrix`, {\r\n          params: {\r\n            timeRange: this.selectedTimeRange,\r\n            coins: coinQueryParam\r\n          }\r\n        })\r\n        this.drawHeatmap(response.data.matrix, response.data.labels)\r\n      } catch (error) {\r\n        console.error('Error fetching correlation matrix:', error)\r\n      }\r\n    },\r\n    drawHeatmap (matrix, labels) {\r\n      // Define the dimensions and margins for the heatmap\r\n      const margin = { top: 80, right: 80, bottom: 80, left: 80 }\r\n      const width = 1000 - margin.left - margin.right\r\n      const height = 400 - margin.top - margin.bottom\r\n\r\n      // Remove any existing SVG to avoid overlapping heatmaps\r\n      d3.select('#heatmap').select('svg').remove()\r\n\r\n      // Append the svg object to the body of the page\r\n      const svg = d3.select('#heatmap')\r\n        .append('svg')\r\n        .attr('width', width + margin.left + margin.right)\r\n        .attr('height', height + margin.top + margin.bottom)\r\n        .append('g')\r\n        .attr('transform', `translate(${margin.left},${margin.top - 80})`)\r\n\r\n      // Build X scales and axis\r\n      const x = d3.scaleBand()\r\n        .range([0, width])\r\n        .domain(labels)\r\n        .padding(0.05)\r\n      svg.append('g')\r\n        .style('font-size', 15)\r\n        .attr('transform', `translate(0,${height})`)\r\n        .call(d3.axisBottom(x).tickSize(0))\r\n        .select('.domain').remove()\r\n\r\n      // Build Y scales and axis\r\n      const y = d3.scaleBand()\r\n        .range([height, 0])\r\n        .domain(labels)\r\n        .padding(0.05)\r\n      svg.append('g')\r\n        .style('font-size', 15)\r\n        .call(d3.axisLeft(y).tickSize(0))\r\n        .select('.domain').remove()\r\n\r\n      // Build color scale\r\n      // eslint-disable-next-line indent\r\n    // Create a diverging color scale\r\n      const myColor = d3.scaleDiverging()\r\n        .interpolator(d3.interpolateRdYlBu) // This is a common diverging color interpolator\r\n        .domain([-1, 0, 1])\r\n\r\n      // After your heatmap squares have been added:\r\n      // Assume myColor is your color scale\r\n\r\n      // Define the legend\r\n      const legendWidth = 300\r\n      const legendHeight = 20\r\n      const legendMargin = { top: 10, right: 60, bottom: 10, left: 60 }\r\n\r\n      // Append a defs (for definition) element to your SVG\r\n      const defs = svg.append('defs')\r\n\r\n      // Append a linearGradient element to the defs and give it a unique id\r\n      const linearGradient = defs.append('linearGradient')\r\n        .attr('id', 'linear-gradient')\r\n\r\n      // Horizontal gradient\r\n      linearGradient\r\n        .attr('x1', '0%')\r\n        .attr('y1', '0%')\r\n        .attr('x2', '100%')\r\n        .attr('y2', '0%')\r\n\r\n      // Set the color for the start (0%)\r\n      linearGradient.append('stop')\r\n        .attr('offset', '0%')\r\n        .attr('stop-color', myColor(0)) // light color\r\n\r\n      // Set the color for the end (100%)\r\n      linearGradient.append('stop')\r\n        .attr('offset', '100%')\r\n        .attr('stop-color', myColor(1)) // dark color\r\n\r\n      // Draw the rectangle and fill with gradient\r\n      svg.append('rect')\r\n        .attr('width', legendWidth)\r\n        .attr('height', legendHeight)\r\n        .style('fill', 'url(#linear-gradient)')\r\n        .attr('transform', `translate(${margin.left}, ${height + margin.top + legendMargin.top})`)\r\n\r\n      // Append title\r\n      svg.append('text')\r\n        .attr('class', 'legend-title')\r\n        .attr('x', margin.left)\r\n        .attr('y', height + margin.top)\r\n        .style('text-anchor', 'left')\r\n        .text('Correlation')\r\n\r\n      // Create a scale and axis for the legend\r\n      const legendScale = d3.scaleLinear()\r\n        .domain([0, 1])\r\n        .range([0, legendWidth])\r\n\r\n      const legendAxis = d3.axisBottom(legendScale)\r\n        .ticks(5)\r\n        .tickFormat(d3.format('.1f'))\r\n\r\n      svg.append('g')\r\n        .attr('class', 'legend-axis')\r\n        .attr('transform', `translate(${margin.left}, ${height + margin.top + legendHeight + legendMargin.top})`)\r\n        .call(legendAxis)\r\n      svg.selectAll()\r\n        .data(matrix.flatMap((row, i) => row.map((value, j) => ({ row: labels[i], column: labels[j], value }))))\r\n        .enter()\r\n        .append('text')\r\n        .text(d => d.value.toFixed(2))\r\n        .attr('x', d => x(d.column) + x.bandwidth() / 2)\r\n        .attr('y', d => y(d.row) + y.bandwidth() / 2)\r\n        .style('text-anchor', 'middle')\r\n        .style('alignment-baseline', 'central')\r\n      // Dynamic fill based on the value\r\n        .style('fill', function (d) {\r\n          // Assuming myColor is the color scale used for the heatmap\r\n          // This example uses a threshold of 0.5, adjust as needed\r\n          const color = myColor(d.value)\r\n          const rgb = d3.rgb(color)\r\n          // A threshold to decide if the color is \"light\" or \"dark\"\r\n          const brightnessThreshold = 150\r\n          const brightness = (rgb.r * 0.299 + rgb.g * 0.587 + rgb.b * 0.114)\r\n          return brightness > brightnessThreshold ? 'black' : 'white'\r\n        })\r\n\r\n      // create a tooltip\r\n      const tooltip = d3.select('#heatmap')\r\n        .append('div')\r\n        .style('opacity', 0)\r\n        .attr('class', 'tooltip')\r\n        .style('background-color', 'white')\r\n        .style('border', 'solid')\r\n        .style('border-width', '2px')\r\n        .style('border-radius', '5px')\r\n        .style('padding', '5px')\r\n        .style('position', 'absolute')\r\n\r\n      // Three functions that change the tooltip when user hovers, moves, or leaves a cell\r\n      const mouseover = function (event, d) {\r\n        tooltip.style('opacity', 1)\r\n        d3.select(this)\r\n          .style('stroke', 'black')\r\n          .style('opacity', 1)\r\n      }\r\n      const mousemove = function (event, d) {\r\n        tooltip.html('Correlation: ' + d.value.toFixed(2))\r\n          .style('left', (event.x) + 'px')\r\n          .style('top', (event.y) + 'px')\r\n      }\r\n      const mouseleave = function (event, d) {\r\n        tooltip.style('opacity', 0)\r\n        d3.select(this)\r\n          .style('stroke', 'none')\r\n          .style('opacity', 0.8)\r\n      }\r\n\r\n      // Add the squares\r\n      svg.selectAll()\r\n        .data(matrix.flatMap((row, i) => row.map((value, j) => ({ row: labels[i], column: labels[j], value }))))\r\n        .enter()\r\n        .append('rect')\r\n        .attr('x', d => x(d.column))\r\n        .attr('y', d => y(d.row))\r\n        .attr('rx', 4)\r\n        .attr('ry', 4)\r\n        .attr('width', x.bandwidth())\r\n        .attr('height', y.bandwidth())\r\n        .style('fill', d => myColor(d.value))\r\n        .style('stroke-width', 4)\r\n        .style('stroke', 'none')\r\n        .style('opacity', 0.8)\r\n        .on('mouseover', mouseover)\r\n        .on('mousemove', mousemove)\r\n        .on('mouseleave', mouseleave)\r\n    }\r\n  }\r\n}\r\n\r\n</script>\r\n\r\n<style>\r\n.tooltip {\r\n  position: absolute;\r\n  text-align: center;\r\n  transition: opacity 0.3s;\r\n}\r\n</style>\r\n"],"mappings":";gCAGMA,mBAAA,CAAoC,YAAhC,6BAA2B;gCAC/BA,mBAAA,CAAwB;EAAnBC,EAAE,EAAC;AAAS;;;uBAFrBC,mBAAA,CAGQ,cAFJC,UAAoC,EACpCC,UAAwB,EAACC,mBAAA,qCAAwC,C"},"metadata":{},"sourceType":"module","externalDependencies":[]}